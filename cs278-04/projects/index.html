<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <title>Luca Trevisan | Computational Complexity</title>
   
   <style>
body{margin:10px 10px 10px 10px;font-family:sans-serif;background-color:#FFFFFb;}
a{text-decoration:none}
a:link{color:#4444aa;}
a:visited{color:#4444aa;}
a:hover{background-color:#aaaaFF;}
li{line-height : 130%;}
</style>
</head>
<body>

<h1>
Projects</h1>
<hr WIDTH="100%">
<p>A project can either be a <i>study</i> project or a <i>research</i> project. </p>
<p>In a study project you focus on an important result, or set of results, that
is not covered in detail in the course. You read the relevant papers and write a
survey paper that describes the results, their motivation, their applications,
and something new. &quot;Something new&quot; could be filling in the details of
an important technical lemma that is only stated without proof (or with a
sketchy proof) in the literature, or observe a simplified argument for a
technical proof, or something along these lines.</p>
<p>A research project starts with a general goal, like &quot;prove a
weakly-non-uniform hierarchy theorem for ZPTIME,&quot; or &quot;improve the
inapproximability result for Metric TSP,&quot; or &quot;Prove P=/=NP.&quot;
Towards this goal, you read the relevant papers, try various approaches, and
then you may or may not reach your goal. At the end you write a report detailing
your efforts.</p>
<p>Study projects should be done independently. If you want to do a study
project, and you strongly prefer to do collaborative work, you can arrange with
a colleague to choose related topics for a study project (for example, one
project could be on impossibility results for random oracles in cryptography and
another could be impossibility results for obfuscation). Then you can study
together, even though two different reports will have to be submitted.</p>
<p>A research project can be assigned to a team of two.</p>
<hr>
<h1>Examples</h1>
<p>Any important result in complexity can be the base for a study project, and
any interesting open question can the base for a research project.</p>
<p>Here are some examples. Ask me for the references. Many entries are
&quot;under construction&quot;. Check this page later for updates (or ask me).</p>
<ul>
  <li>Prove a <b>hierarchy theorem for ZPTIME</b>. (Research project.)<br>
    Barak, and then Fortnow and Santhanam prove hierarchy theorems for BPTIME
    with advice. It is open how to get similar results for ZPTIME.
    (Update:&nbsp; a hierarchy theorem for RTIME has been announced).</li>
  <li><b>Conditional derandomization</b>. (Study project.)<br>
    Study some subset of the following papers:&nbsp; Nisan-Wigderson (basic
    trade-off between average-case complexity and derandomization),
    Impagliazzo-Wigderson (worst-case to average-case equivalence)
    Sudan-Trevisan-Vadhan (&quot;simplified&quot; proof of Impagliazzo-Wigderson)
    Shaltiel-Umans (algebraic construction of pseudorandom generators).<br>
    There is at least one interesting and perhaps feasible question here: to
    derive &quot;uniform&quot; versions of the above results, improving on
    partial results by Impagliazzo-Wigderson (a different paper, not the one
    referenced above) and Trevisan-Vadhan.</li>
  <li>&nbsp;<b>Theory of cryptography</b> (many possible study projects)
    <ul>
      <li>Proof by Hastad, Impagliazzo, Levin and Luby that pseudorandom
        generators exist if one-way functions exist.<br>
        Here I would really like the ambitious project of re-writing the proof,
        at least the non-uniform version,&nbsp; with &quot;concrete&quot;
        parameters and an understandable, modular presentation.</li>
      <li>The non-black-box zero-knowledge proof system of Barak</li>
      <li>Positive and negative results about the random oracle model</li>
      <li>Negative results on obfuscation. Here there may be room for a research
        project as well</li>
      <li>. . . </li>
    </ul>
  </li>
  <li><b>Unconditional Derandomization</b>
    <ul>
      <li>Derandomization of polynomial identity testing for polynomials
        computed by &quot;non-commutative branching programs&quot;<br>
        See the paper of Shpilka and Raz <a href="http://www.wisdom.weizmann.ac.il/~ranraz/publications/indexDR.html">[here]
        </a></li>
      <li>Derandomization of approximate counting of satisfying assignments
        of&nbsp; DNF (project chosen by Omid)</li>
    </ul>
  </li>
  <li><b>Average-case complexity in NP</b>
    <ul>
      <li>Impossibility results for worst-case to average-case equivalence for
        NP-complete problems (Feigenbaum-Fortnow, Bogdanov-Trevisan, Viola)</li>
      <li>Amplification of average-case hardness of problems in NP (O'Donnell, .
        . . )</li>
    </ul>
  </li>
  <li><b>Average-case complexity of lattice problems</b>
    <ul>
      <li>Existence of lattice problems that are as hard on average as on worst
        case (Ajtai, Regev, ...)</li>
      <li>Existence of public key cryptosystems of security equivalent to the
        worst case complexity of a lattice problem (Ajtai-Dwork, Regev...)</li>
    </ul>
  </li>
  <li><b>Interactive proofs with &quot;efficient&quot; prover </b>(research
    project)
    <ul>
      <li>Consider the question of whether there can be an interactive proof for
        coNP where the prover can be implemented using a P^NP algorithm. Under
        what conditions can this be ruled out? It is related to the question of
        NP-complete problems having &quot;instance checkers&quot;,
        &quot;random-self-reducibilities&quot; and &quot;self-testers&quot;. </li>
    </ul>
  </li>
  <li><b>Inapproximability results </b>based on the &quot;unique games
    conjecture&quot;
    <ul>
      <li>Hardness of Vertex Cover within 2 and of k-uniform Hypergraph Vertex
        Cover within k</li>
      <li>Hardness of Max CUT within .878... (with additional assumptions)</li>
    </ul>
  </li>
  <li><b>Proof complexity</b>
    <ul>
      <li>Lower bounds on resolution using width</li>
      <li>Lower bounds on datalog programs to refute random instances of 3SAT</li>
    </ul>
  </li>
  <li>Results in <b>computational learning theory&nbsp; </b>(Sebastien)
    <ul>
      <li>Learning using&nbsp; Fourier Analysis, harmonic sieve algorithm</li>
    </ul>
  </li>
  <li>Lower bounds for <b>monotone circuits</b>
    <ul>
      <li>Razborov's lower bound for clique</li>
      <li>The depth lower bound for st-connectivity</li>
    </ul>
  </li>
  <li>Lower bounds in <b>communication complexity</b>
    <ul>
      <li>The Babai-Nisan-Szegedy &quot;number on the forehead&quot; model</li>
    </ul>
  </li>
  <li>Lower bounds for <b>algebraic circuits</b>
    <ul>
      <li>Nisan's lower bound for non-commutative computations</li>
      <li>Raz's lower bound for multilinear formulas (Project chosen by Satrajit)</li>
      <li>Impagliazzo-Kabanets connection between algebraic complexity and
        derandomization of polynomial identity testing</li>
    </ul>
  </li>
</ul>
<p>&nbsp;</p>



</body>
</html>
