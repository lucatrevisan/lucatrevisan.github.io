<html>

<head>
  <link rel="stylesheet" href="../luca.css" type="text/css">

<title>Fall 2019 | 30516 Theoretical Computer Science</title>


</head>

<body><center>
    <h1>Fall 2019 &mdash; 30516 Theoretical Computer  Science</h1>
</center>

    This course introduces the beautiful and powerful techniques of theoretical computer science for the design of algorithms, the analysis of algorithms, and the study of the computational complexity of problems. Time permitting, we will also get a glimpse into the design and analysis of cryptographic protocols. More information will provided about a week before the start of classes.
    
    <hr>
    
    <h3>General information</h3>
    
    Instructor: <a href="../index.html">Luca Trevisan</a>
    
    <p>
    
    Lectures:
    <ul>
        <li>Wednesdays 10:30-noon</li>
        <li>Thursdays 16:15-17:45</li>
        </ul>
    
    <p>
    
    Office hours:
    <ul>
        <li> Luca: Thursdays 11-noon in 3-E1-14 Roentgen (from Sept 12 to Dec 5)</li>
        <li>Niccol√≤: Tuesdays 10:30-12:30 in 3-E2-FN02 (until Dec 10)</li>

    <p>
    
    <hr>
    
    <h3>Textbooks and other readings</h3>
    
    There is no required textbook. Readings will be assigned for each lecture.
    
    <p>
    
    A good reference for the analysis of algorithms is
    
    <ul><li>J Kleinberg and E Tardos. <i>Algorithm Design</i>
        </li></ul>
    
    A great introduction to computational complexity is
    
    <ul><li>M Sipser. <i>Introduction to the Theory of Computation</i></li></ul>
    
    Another great and very readable reference for both analysis of algorithms and computational complexity is
    
    <ul><li>S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani. Algorithms</li></ul>
    
    It is easy to find online a pdf of the Dasgupta et al. book. As far as I know, these pdf copies are circulating with the blessing of the authors.
    
    <p>
    
    For the lectures on cryptography, we will refer <a href=https://lucatrevisan.github.io/books/crypto.pdf>to my notes</a>
    
    <hr>
    
    <h3>Exercises</h3>
    
    <ol>
        <li> <a href=pset1v2.pdf>Problem Set 1 (updated Oct 7)</a> covers lectures 1-6<br>
            [<a href=pset1-sol.pdf>Solutions</a>]
            </li>
        
        <p>
        
        <li> <a href=pset2.pdf>Problem Set 2</a> covers lectures 7-12<br>
            [<a href=pset2-sol.pdf>Solutions</a>]
            </li>
        
        </ol>
    
    
    <hr>
    
    <h3>Past lectures</h3>
    
    <ol>
        <li> Description of the course. Big-Oh notation. Divide-and-conquer technique. Description of Mergesort and proof that it runs in O(nlogn) time <br>
            <a href=lecture01.pdf>[Lecture Notes for Lecture 1]</a><br>
            Readings: review mathematical prerequisites and big-Oh notation, e.g. Dasgupta Chapter 0. Divide-and-conquer idea and mergesort, Dasgupta Sections 2.2 and 2.3
            </li>
        
        <p>
        
        <li> Divide-and-conquer algorithm for multiplication of large integers. Statement and proof of the Master Theorem.<br>
            <a href=lecture02.pdf>[Lecture Notes for Lecture 2]</a><br>
            Readings: Dasgupta Sections 2.1 and 2.2</li>
        
        <p>
        
        <li> Randomized median algorithm with expected linear time. Definition of graphs, directed and undirected graphs, reachability, and connected components. Introduction to DFS. DFS as an algorithm for discovering the connected components of an undirected graph.<br>
                  <a href=lecture03v2.pdf>[Lecture Notes for Lecture 3 (updated October 7)]</a><br>
            Readings: Dasgupta Sections 2.4, 3.1 and 3.2</li>
        
        <p>
        
        <li> Analysis of DFS for finding connected components of undirected graphs, DFS for finding topological sort of directed acyclic graphs, DFS for finding strongly connected components of directed graphs.<br>
            Readings: Dasgupta Sections 3.3 and 3.4</li>
        
        <p>
        
        
        <li> Minimum spanning tree problem: Kruskal's algorithm and the union-find data structure.<br>
            Readings: Dasgupta Section 5.1 (you can skip the discussion of Prim's algorithm)</li>
        
        <p>
        
        <li> More on minimum spanning trees and union-find.<br>
            Same readings as previous lecture
            </li>
        
        <p>
        
        <li> Shortest path problem. Linear-time algorithm for DAGs. Dijkstra's algorithm and intuition for correctness.<br>
            Readings: Dasgupta Sections 4.3, 4.4 and 4.7
            </li>
        
        <p>
        
        <li> Rigorous proof of correctness of Dijkstra's algorithm. Priority queue data structure and implementation using binary heaps.<br>
            Readings: Dasgupta Sections 4.4 and 4.5
            
            </li>
            
        <p>
        
        <li> More on binary heaps implementation. Discussion of the shortest path problem if negative edge lengths are present.<br>
            Readings: Dasgupta 4.5 and 4.6
            </li>
        
        <p>
        
        <li> Introduction to the maximum flow problem: definition of the problem, notion of residual network, definition of capacity of a cut, Ford-Fulkerson algorithm, statement of the Max Flow - Min Cut Theorem<br>
            Readings: Dasgupta 7.2, and chapter 9 of <a href=https://lucatrevisan.github.io/books/cs261.pdf>these notes</a>
            </li>
        
        <p>
        
        <li> Proof of correctness of Ford-Fulkerson and proof of max-flow min-cut theorem. Discussion of efficiency of Ford-Fulkerson implementation, and of the Edmonds-Karp algorithm.<br>
            Readings: same as last lecture and Section 11.2 of <a href=https://lucatrevisan.github.io/books/cs261.pdf>these notes</a>
            </li>
        
        <p>
        
        <li> Applications of maximum flow algorithms: maximum flow with vertex capacities, bipartite graphs, perfect matchings in bipartite graphs, maximum matching in bipartite graphs.<br>
            Readings: Dasgupta 7.3, and sections 14.1 and 14.2 of <a href=https://lucatrevisan.github.io/books/cs261.pdf>these notes</a></li>
        
        <p>
        
        <li> Dynamic programming: Edit distance.<br>
            Readings: 6.3 (sections 6.1 and 6.2 give addtional context and examples)
            </li>
        
        <p>
        
        
        </ol>
    
    <hr>
    
    <h3>Lecture plan</h3>
    
    (May change slightly as the semester progresses)
    
    <P>
    
    <ol>
        <li> Introduction, review of basic data structures and of asymptotic analysis. Sorting in quadratic and O(n log n) time
        </li>
        
        <li> Multiplication of large integers in less than quadratic time. General divide-and-conquer methodology, master theorem
        </li>
        
        <li> Basic graph algorithms 1
        </li>
        
        <li> Basic graph algorithms 2
        </li>
        
        <li> Basic graph algorithms 3
        </li>
        
        <li> Basic graph algorithms 4
        </li>
        
        <li> Basic graph algorithms 5
        </li>
        
        <li> Basic graph algorithms 6
        </li>
        
        <li> Basic graph algorithms 7
        </li>
        
        <li> Maximum flow 1
        </li>
        
        <li> Maximum flow 2
        </li>
        
        <li> Dynamic programming 1
        </li>
        
        <li> Dynamic programming 2
        </li>
        
        <li> Dynamic programming 3
        </li>
        
        <li> P and NP
        </li>
        
        <li> Reductions and NP-completeness
        </li>
        
        <li> NP-complete problems
        </li>
        
        <li> NP-complete problems
        </li>
        
        <li> Undecidability of the Halting problem
        </li>
        
        <li> More undecidable problems
        </li>
        
        <li> Godel's theorem
        </li>
        
        <li> Cryptography 1
        </li>
        
        <li> Cryptography 2
        </li>
        
        <li> Cryptography 3
        </li>
        </ol>
    
    
</body>

</html>
